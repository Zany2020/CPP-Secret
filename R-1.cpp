#define _CRT_SECURE_NO_WARNINGS
#include<iostream>
#include<string>
//提供 std::string 字符串类 + std::getline 等字符串类操作

//c++头文件后面的.h去掉然后前面再加个c
//#include<cstring>
//提供 C 语言风格字符串的库函数（如strlen、strcpy、strcat）

using namespace std;//必加

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////

//int main()
//{
//	int n;
//	const int m = 4321;//宏定义can't change
//	cin >> n;
//	cout << "hello world " << n << " " << m << endl;  //endl是换行符;
//	cin.get();
//}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////

//int main()
//{
//	//string n = "Akane";
//	//getline(cin, n);//读取一整行（包括空格）
//	//cout << n << endl;
//	//cout << n.length() << endl;
//
//	string s = "oshino ko";
//	cout << s << endl;
//	string s_sub = s.substr(2, 5);//从第二个字符开始取5个字符（包括空格）
//	cout << s_sub << endl;
//
//	return 0;
//}
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////

//struct rem {
//	string m;
//	int n;
//};//省略了typedef，直接用rem命名就OK了
//
//int main()
//{
//	rem a[10];//省略了struct
//
//}
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////

//void c(int& a)//这里的&相当于传参，没有&函数不起作用输出结果为233
//{
//	a += 1;
//}
//
//int main()
//{
//	int a = 233;
//	c(a);
//	cout << a << endl;
//
//	return 0;
//}
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////

//#include<vector>
//int main()
//{
//	vector <int> v;
//
//	v.resize(10);//赋给10个空间
//	for (int i = 0; i < 10; i++)
//		v[i] = i;
//
//	v.push_back(666);//在末尾添加一个数据
//
//	for (int i = 0; i < 11; i++)
//		cout << v[i] << " ";
//	cout << endl;
//
//
//	vector <int> m(5, 33);//赋5个33
//	for (int i = 0; i < 5; i++)
//		cout << m[i] << " ";
//	cout << endl;
//
//
//	vector <int> n;
//	n.resize(8, 1);
//	n.push_back(233);
//	for (auto p = n.begin(); p != n.end(); p++)//遍历
//	//n.begin(): “包装了地址的迭代器”，用法和指针一样，但本质是容器提供的遍历工具
//	//auto会让编译器根据变量的初始化值，自动推断出变量的类型
//		cout << *p << " ";
//
//	return 0;
//}
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////

//#include<set>
//
//int main()
//{
//	set <int> s;
//	//s后面不能加东西;加了就是空集不成立,(2，3)这种也不行因为集合内的元素都是互异的
//
//	s.insert(1);
//	s.insert(2);
//	s.insert(3);
//
//	for (auto p = s.begin(); p != s.end(); p++)
//		cout << *p << " ";
//	cout << endl ;
//
//	cout << (s.find(2) != s.end()) << endl;//find是全部元素找,set的是二分查找效率更高
//	cout << (s.find(4) != s.end()) << endl;
//
//	s.erase(1);//这个是删除
//	cout << (s.find(1) != s.end()) << endl;
//
//
//	return 0;
//}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////

//#include<map>//键值对
//
//int main()
//{
//	map <string, int> m;
//	//类似与包含string 和 int类型的结构体;
//
//	m["Akane"] = 163;
//	m["Kana"] = 150;
//
//	cout << "Akane's height :" << m["Akane"] << endl;
//	
//	for (auto p = m.begin(); p != m.end(); p++)
//		cout << p->first << " : " << p->second << endl;
//
//	cout << "m的长度为：" << m.size() << endl;
//
//	return 0;
//}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//#include <stack> //栈
//
//int main()
//{
//	stack <int> s;
//	s.push(1);//push压栈
//	s.push(520);
//	s.push(233);
//	cout << s.top() << endl;//top访问栈顶
//
//	s.pop();//pop出栈
//	s.push(666);
//
//	cout << s.top() << endl;
//
//	cout << "栈的长度为：" << s.size() << endl;//size访问长度
//
//	//for (auto p = s.begin(); p != s.end(); p++)
//	//	cout << *p << endl;
//	//不能这样因为栈只能操作栈顶
//
//}
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////

//#include<queue> //队列
//
//int main()
//{
//	queue <int> s;
//	//可以操作队首队尾
//
//	s.push(i) -> 入队
//	s.pop() -> 出队
//	s.front() -> 访问队首
//	s.back() -> 访问队尾
//	s.size() -> 获取长度
//
//}
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////

//在map和set前面加上unordered_就是省略了排序的过程；刷题的时候超时了就用这个
//但是记得包含头文件#include<unorder_map>这种

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////
